Index: BOP.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/BOP.py b/BOP.py
--- a/BOP.py	
+++ b/BOP.py	
@@ -1,1 +1,322 @@
+"""
+Created on Thu May 14 16:51:06 2020
+
+@author: diego
+"""
+
+from gurobipy import *
+from gurobipy import quicksum
+from gurobipy import GRB
+from gurobipy import Model
+
+import pandas as pd
+import numpy as np
+
+np.random.seed(0)
+
+
+######## da riferimento ########
+# instance = '2018-05-26'
+################################
+
+
+# for instance in list_instances:
+
+def VRP_model(distance, duration, demand, time_info, trucks_info, solver, gap, time_limit):
+    l = demand
+
+    distance = distance.values
+    travel_cost = distance * (0.9)
+
+    duration = duration.values
+
+    m = Model('VRP')
+
+    n = int((len(distance) - 2) / 2)  # numero di clienti totali
+    k = len(trucks_info)
+    K = np.arange(0, k).tolist()  # lista dei veicoli
+    Cap = trucks_info  # capacità dei k veicoli random int tra 1 e 2
+
+    # crea un array di tutti i possibili nodi di pickup e delivery partendo da 1 fino al doppio dei clienti, tolist: trasforma l'array in lista
+    N = np.arange(1, (2 * n) + 1, 1).tolist()
+    P = N[:n]  # insieme clienti su cui fare pickup
+    D = N[n:]  # insieme di clienti su cui fare delivery
+
+    Or = [0]  # deposito innocenti origine
+    Dest = [len(N) + 1]  # deposito innocenti destinazione
+
+    ##################### Insiemi secondo la formulazione di Vigo ############
+    Nod = Or + N + Dest
+
+    Po = Or + P
+    Pd = P + Dest
+
+    No = Or + N
+    Nd = N + Dest
+
+    Do = Or + D
+    Dd = D + Dest
+
+    Od = Or + Dest
+    ##########################################################################
+
+    a = []
+    b = []
+    for i in time_info:
+        a.append(i[0].hour + i[0].minute / 60)
+        b.append(i[1].hour + i[1].minute / 60)
+
+    ##########################################################################
+
+    s = []
+    for i in Nod:
+        if l[i] == 0:
+            s.append(0)
+        elif l[i] == 1:
+            s.append(time_info[i][2].minute / 60)  # quando carico un'unità ci metto il tempo indicato
+        elif l[i] == -1:
+            s.append(time_info[i][
+                         2].minute / 60 - 5 / 60)  # quando scarico un'unità ci metto 5 minuti in meno di caricarne una
+        elif l[i] == -2:
+            s.append(time_info[i][
+                         2].minute * 2 / 60 - 10 / 60)  # quando scarico due unità ci metto 10 minuti in meno di caricarne 2
+        else:
+            s.append(time_info[i][2].minute * 2 / 60)  # quando carico due unità ci metto il doppio
+
+    M = 1000
+    M2 = 2
+
+    max_turno = 12
+
+    # Variables
+
+    x = {(i, j, k): m.addVar(lb=0, ub=1, vtype=GRB.BINARY, obj=travel_cost[i, j], name='x,{},{},{},'.format(i, j, k))
+         for i in Nod for j in Nod for k in K}
+
+    T = {(i, k): m.addVar(lb=0, vtype=GRB.CONTINUOUS, name='T({},{})'.format(i, k)) for i in Nod for k in K}
+
+    L = {(i, k): m.addVar(lb=0, ub=2, vtype=GRB.INTEGER, name='L({},{})'.format(i, k)) for i in Nod for k in K}
+
+    # Constraints
+
+    ###############################################################################################
+    #########  1  ### IL CARICO QUANDO ESCO DALL'ORIGINE E QUANDO TORNO ALLA DEST DEVE ESSERE PARI A ZERO
+    for k in K:
+        m.addConstr((quicksum(L[i, k] for i in Od)) == 0, name='Inizio_fine_0({})'.format(k))
+
+    ###############################################################################################
+    #########  2  ### OGNI NODO DEVE ESSERE SERVITO DA UN SOLO VEICOLO
+    for i in P:
+        m.addConstr(quicksum(x[i, j, k] for k in K for j in Nd if j != i) == 1, name='Servizio_nodo_({})'.format(i))
+
+    ###############################################################################################
+    #########  3  ### DEVO VISITARE PRIMA IL NODO DI PICKUP E POI IL RISPETTIVO DELIVERY
+    for k in K:
+        for i in P:
+            m.addConstr(
+                (quicksum(x[i, j, k] for j in N if j != i)) == (quicksum(x[j, n + i, k] for j in N if j != (n + i))),
+                name='pick_deliv({}_{})'.format(k, i))
+
+    # NB : con i vincoli 4 e 5 old la f.o. cresce all'aumentare del parametro k, con i vincoli 4 e 5 new non varia.
+    ###############################################################################################
+    #########  4 new ### Tutti i veicoli che sono utilizzati partono da Innocenti
+    for k in K:
+        m.addConstr(quicksum(x[0, j, k] for j in P) <= 1, name='or_Inno({})'.format(k))
+
+        ###############################################################################################
+    #########  4 old ### Tutti i veicoli sono utilizzati e partono da Innocenti
+    # for k in K:
+    #     m.addConstr(quicksum(x[0,j,k] for j in P ) == 1 , name = 'or_Inno({})'.format(k))
+
+    ###############################################################################################
+    #########  5 new ### Tutti i veicoli che sono usciti allora toranano ad Innocenti
+    for k in K:
+        m.addConstr(quicksum(x[i, Dest[0], k] for i in D if i != Dest[0]) == quicksum(x[0, j, k] for j in P),
+                    name='dest_Inno({})'.format(k))
+
+    ###############################################################################################
+    #########  5 old ### Tutti i veicoli tornando ad Innocenti
+    # for k in K:
+    #     m.addConstr(quicksum (x[i,Dest[0],k] for i in D if i != Dest[0]) == 1 , name = 'dest_Inno({})'.format(k))
+
+    ###############################################################################################
+    #########  6  ### OGNI VEICOLO CHE ENTRA IN UN NODO DEVE USCIRE DALLO STESSO
+    for k in K:
+        for j in N:
+            m.addConstr((quicksum(x[i, j, k] for i in No if i != j)) == (quicksum(x[j, i, k] for i in Nd if i != j)),
+                        name='Visita_nodo({}_{})'.format(k, j))
+
+            ################################################################################################
+    #########  7  ### VINCOLI TEMPORALI
+    for k in K:
+        for i in Nod:
+            for j in Nod:
+                if i == j:
+                    continue
+                m.addConstr((T[i, k] + s[i] + duration[i, j] - T[j, k]) <= M * (1 - x[i, j, k]),
+                            name='Vinc_temp1({}_({},{}))'.format(k, i, j))
+
+    ################################################################################################
+    ########  8  ### VINCOLI FINESTRE TEMPORALI NODI
+    for k in K:
+        for i in N:
+            m.addConstr(a[i] <= T[i, k], name='Vinc_fines1({}_{})'.format(k, i))
+
+    for k in K:
+        for i in N:
+            m.addConstr(T[i, k] <= b[i], name='Vinc_fines2({}_{})'.format(k, i))
+
+    ################################################################################################
+    #########  9  ### VINCOLI TEMPORALI TRA PICKUP E DELIVERY
+    for k in K:
+        for i in P:
+            m.addConstr(T[i, k] + duration[i, n + i] + s[i] <= T[n + i, k], name='Pick_Deliv-Route({}_{})'.format(k, i))
+
+    ################################################################################################
+    ########  10  ### VINCOLI CARICO CON BIG M
+    for k in K:
+        for i in N:
+            for j in N:
+                if i == j:
+                    continue
+                m.addConstr(L[i, k] + l[j] - L[j, k] <= M2 * (1 - x[i, j, k]),
+                            name='Vinc_cap({}_({},{}))'.format(k, i, j))
+
+    ################################################################################################
+    #########  11  ### VINCOLI ATTIVAZIONE CARICO E RISPETTO CAPACITA VEICOLO PER PICKUP
+    for k in K:
+        for i in P:
+            m.addConstr(L[i, k] >= (l[i] * (quicksum(x[i, j, k] for j in N if j != i))),
+                        name='Pickup_coerenza({}_{})'.format(k, i))
+            m.addConstr((L[i, k] <= Cap[k]), name='Pickup_coerenza2({}_{})'.format(k, i))
+
+    ################################################################################################
+    ########  12  ### VINCOLI ATTIVAZIONE CARICO E RISPETTO CAPACITA VEICOLO PER DELIVERY
+    for k in K:
+        for i in D:
+            m.addConstr(L[i, k] <= (Cap[k] - l[i]) * (quicksum(x[i, j, k] for j in N if j != i)),
+                        name='Pickup_limite_capacita({}_{})'.format(k, i))
+
+    ################################################################################################
+    ########  13  ### VINCOLI LIMITAZIONE ORARIO GIORNALIERO
+    for k in K:
+        m.addConstr((quicksum((s[i] + duration[i, j]) * x[i, j, k] for i in Nod for j in Nod if i != j)) <= max_turno,
+                    name='Vinc_turno({})'.format(k))
+
+    ################################################################################################
+    ########  14  ### DAL NODO ORIGINE NON POSSO ANDARE DIRETTAMENTE AD UN NODO DI DELIVERY
+    for k in K:
+        for j in Dd:
+            m.addConstr(x[0, j, k] == 0, name='Vinc_no_Or_Node_Delivery({}_{})'.format(k, j))
+
+    ################################################################################################
+    ########  15  ### EVITO CICLO SU STESSO NODO SENZA FARE ROUTING
+    for k in K:
+        for i in Nod:
+            m.addConstr(x[i, i, k] == 0, name='Ciclo_nodo({}_{})'.format(k, i))
+
+    ################################################################################################
+    ########  16  ### NESSUN VEICOLO DEVE TORNARE ALL'ORIGINE
+    for k in K:
+        for i in N:
+            m.addConstr(x[i, 0, k] == 0, name='No_ritorno_origine({}_{})'.format(k, i))
+
+    ################################################################################################
+    ################################################################################################
+
+    m.setParam(GRB.Param.TimeLimit, 5)
+
+    m.modelSense = GRB.MINIMIZE
+    m.update()
+    m.optimize()
+
+    status = m.status
+    if status == GRB.Status.INFEASIBLE:
+        status = "infeasible"
+        performances = [len(P), "infeasible", "infeasible", "infeasible", "infeasible", "infeasible", "infeasible",
+                        "infeasible", "infeasible", "infeasible", "infeasible", "infeasible"]
+        performances = pd.Series(performances,
+                                 index=['customers #', 'status', 'optObjVal', 'bestObjBound', 'Runtime', 'IterCount',
+                                        'NodeCount', 'NumConstrs', 'NumVars', 'NumBinVar', 'NumIntVar', 'Gap'])
+        performances.to_excel('Performances_VRP_' + (instance) + '.xlsx', na_rep='nan')
+        solution = "infeasible"
+        # m.computeIIS()
+        # m.write('VRP.ilp')
+
+    if status == GRB.Status.OPTIMAL:
+        status = "optimal"
+        obj_val = m.ObjVal
+
+        x = pd.Series(x)
+        T = pd.Series(T)
+        L = pd.Series(L)
+
+        x = x.apply(lambda x: x.X)
+        T = T.apply(lambda x: x.X)
+        L = L.apply(lambda x: x.X)
+
+        LT_sol = pd.concat([L, T], axis=1)
+        LT_sol.columns = ['Load L', 'Time T']
+        LT_sol = LT_sol.reset_index()
+        LT_sol.rename(columns={'level_0': 'Node i', 'level_1': 'Truck k'}, inplace=True)
+
+        for v in m.vars:
+            var_results.append([v.name, v.x])
+
+        var_results = pd.DataFrame.from_records(var_results, columns=["variable", "value"])
+
+        x_opt = var_results[var_results['variable'].str.contains("x", na=False)]
+        T_opt = var_results[var_results['variable'].str.contains("T", na=False)]
+        L_opt = var_results[var_results['variable'].str.contains("L", na=False)]
+
+        x_opt['value'] = x_opt['value'].apply(pd.to_numeric).astype(int)
+        L_opt['value'] = L_opt['value'].apply(pd.to_numeric).astype(int)
+
+
+    elif status == 9:  # TIME-LIMIT
+        status = "Time limit reached"
+        optObjVal = m.getAttr(GRB.Attr.ObjVal)
+        bestObjBound = m.getAttr(GRB.Attr.ObjBound)
+        Runtime = m.Runtime
+        IterCount = m.getAttr(GRB.Attr.IterCount)
+        NodeCount = m.getAttr(GRB.Attr.NodeCount)
+        NumConstrs = m.getAttr(GRB.Attr.NumConstrs)
+        NumVars = m.getAttr(GRB.Attr.NumVars)
+        NumBinVar = m.getAttr(GRB.Attr.NumBinVars)
+        NumIntVar = m.getAttr(GRB.Attr.NumIntVars)
+        Gap = m.MIPGap
+        performances = [len(P), status, optObjVal, bestObjBound, Runtime, IterCount, NodeCount, NumConstrs, NumVars,
+                        NumBinVar, NumIntVar, Gap]
+        performances = pd.Series(performances,
+                                 index=['customers #', 'status', 'optObjVal', 'bestObjBound', 'Runtime', 'IterCount',
+                                        'NodeCount', 'NumConstrs', 'NumVars', 'NumBinVar', 'NumIntVar', 'Gap'])
+        performances.to_excel('Performances_VRP_prov' + (instance) + '.xlsx', na_rep='nan')
+
+        x = pd.Series(x)
+        T = pd.Series(T)
+        L = pd.Series(L)
+
+        x = x.apply(lambda x: x.X)
+        T = T.apply(lambda x: x.X)
+        L = L.apply(lambda x: x.X)
+
+        LT_sol = pd.concat([L, T], axis=1)
+        LT_sol.columns = ['Load L', 'Time T']
+        LT_sol = LT_sol.reset_index()
+        LT_sol.rename(columns={'level_0': 'Node i', 'level_1': 'Truck k'}, inplace=True)
+
+        Truck_sol = []
+        for k in K:
+            Truck_sol.append(LT_sol[LT_sol["Truck k"] == k])
+
+        x_sol = x[x > 0].index
+        solution = [x, x_sol, LT_sol, Truck_sol]
+
+        m.write('WFA_Diego.lp')
+
+    # return performances, solution
+    return status
+
+
+
 
